\chapter*{Abstract}

Modern compiled software, written in languages such as C and C++, relies on complex compiler infrastructure that transforms programs in ways that improve their non-functional characteristics. However, developing new transformations and improving existing ones can be challenging to researchers and engineers. Often, transformations are conceived in terms of the high-level language, but must be implemented by transforming a lower-level intermediate representation (IR) or by modifying the compiler itself, which may not be feasible, for technical or legal reasons.

Source-to-source compilers make it possible to directly analyze and transform the original source, making transformations portable across different compilers. This approach allows transformations to be composed upstream of the compilation toolchain, allowing rapid research and prototyping of source code transformations, and its use has been proposed as a solution for implementing program transformations whenever it would prove to be infeasible or impractical to do so at the compiler level. One such tool is Clava, which embeds a scriptable Javascript environment and provides access to the Abstract Syntax Trees of C and C++ programs, allowing the source code to be queried and manipulated.

However, this approach has the drawback of exposing the researcher to the full breadth of the source language, which is often more extensive and complex than the IRs used in traditional compilers. Because of that complexity, it is hard to perform complete analyses that can account for all edge cases in the language. On the other hand, those constructs, such as loops or structures, can be useful to encode properties that are not made explicit in lower-level representations.

In this work, we propose a solution to tame the complexity of the source language and make source-to-source compilers an ergonomic platform for program optimization work, by dividing the transformations into two distinct steps. First, we define a simpler subset of the language that can encode the programs with fewer primitives, and implement a set of transformations, termed normalizations, to transform the input programs into equivalent programs expressed in that subset. Afterwards, we implement a function inlining transformation as a case study, showing how the assumptions afforded by using a simpler language subset allow us to successfully apply the transformation to codes that would otherwise not be able to be transformed.

We validate our experiment and evaluate our work by comparing the application of optimizations with and without normalization, in terms of the number of transformation cases successfully applied and the performance of the resulting programs, and test the composability of several transformations. On the one hand, the inlining transformations we tested were able to take advantage of the normalized language, regardless of whether they were developed with a normalized program in mind. Our performance testing also suggests that, in general, source-to-source compilation is a good technique to apply optimizations when using less developed compilers. On the other hand, we observed challenges when composing our transformations with existing source-code transformations, which expected  primitives that were not kept in the subset, such as for loops.

\vspace*{10mm}\noindent
\textbf{Keywords}: source-to-source compilers, source-code optimization, source-code normalization

\chapter*{Resumo}

O software compilado de hoje (escrito por exemplo em C ou C++) depende de infraestruturas de compilação complexas que transformam programas de maneira a melhorar as suas caraterísticas não funcionais. No entanto, desenvolver novas transformações e melhorar as existentes pode provar-se um desafio para investigadores e engenheiros. Frequentemente, as transformações são concebidas pensando na linguagem de alto nível, mas precisam de ser implementadas como transformações de uma representação intermédia (IR) menos abstrata, ou mesmo através de modificações dos compiladores, o que poderá não ser viável por motivos técnicos ou legais.

Os compiladores \textit{source-to-source} permitem analisar e transformar diretamente o código-fonte original, tornando as transformações portáteis entre diferentes compiladores. Esta abordagem permite que as transformações sejam compostas a montante das ferramentas de compilação, permitindo uma rápida investigação e prototipagem de transformações de código, e o seu uso tem sido proposto como uma solução para a implementação de transformações de programas, sempre que fazê-lo ao nível dos compiladores seja inviável ou inconveniente. Uma dessas ferramentas é o Clava, que contém um ambiente de execução programável em Javascript e dá acesso às Árvores de Síntaxe Abstratas de programas em C e C++, permitindo a interrogação e transformação do código-fonte.

No entanto, esta abordagem tem a desvantagem de expor o investigador a toda a largura da linguagem de fonte, que frequentemente é mais extensa e complexa do que as IRs usadas nos compiladores tradicionais. Devido a essa complexidade, é difícil efetuar análises completas, que possam ter em conta todos os detalhes e exceções da linguagem. Por outro lado, estes construtos, como ciclos e estruturas, podem ser úteis para codificar propriedades que não são explícitas nas representações de nível mais baixo.

Neste trabalho, propomos uma solução para domar a complexidade da linguagem de fonte e tornar a compilação \textit{source-to-source} uma plataforma ergonómica para trabalho de otimização de programas, através da divisão das transformações aplicadas em dois passos distintos. Primeiro, definimos um subconjunto simplificado da linguagem, que possa codificar os programas escritos nela com menos primitivas, e implementamos um conjunto de transformações, apelidadas de normalizações, para transformar os programas-alvo em programas equivalentes expressos nesse subconjunto. De seguida, implementamos uma transformação de \textit{inlining} como caso de estudo, mostrando como as assunções que emergem do uso da linguagem simplificada permitem-nos aplicar com sucesso a transformação a códigos à qual esta não seria aplicável.

Validamos a nossa experiência e avaliamos o nosso trabalho, comparando a aplicação de otimizações com e sem normalização, em termos do número de casos transformáveis e do desempenho dos programas resultantes, e testamos a capacidade de composição de várias transformações. Por um lado, as transformações de \textit{inlining} testadas foram beneficiadas pelo processo de normalização, independentemente de terem sido desenvolvidas com programas normalizados em mente. Os nossos testes de desempenho também sugerem que a compilação \textit{source-to-source}, genericamente, é uma boa técnica para aplicar otimizações em conjunto com compiladores menos desenvolvidos. Por outro lado, observamos desafios ao compor as nossas transformações com transformações de código-fonte pré-existentes, que esperavam primitivas que não foram mantidas no subconjunto, tais como ciclos \textit{for}.

\vspace*{10mm}\noindent
\textbf{Keywords}: compiladores source-to-source, otimização de código fonte, normalização de código fonte
